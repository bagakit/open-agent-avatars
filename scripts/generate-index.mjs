#!/usr/bin/env node
/* eslint-disable no-console */

import fs from "node:fs";
import path from "node:path";

const ROOT = path.resolve(process.cwd());

function isBatchDirName(name) {
  return /^\d{8}$/.test(name);
}

function listBatchDirs() {
  return fs
    .readdirSync(ROOT, { withFileTypes: true })
    .filter((d) => d.isDirectory() && isBatchDirName(d.name))
    .map((d) => d.name)
    .sort();
}

function toTitle(tokens) {
  return tokens.join(" ").replace(/\s+/g, " ").trim();
}

function parseFilename(filename) {
  const ext = path.extname(filename);
  const base = ext ? filename.slice(0, -ext.length) : filename;
  const m = base.match(/^(.*)_(\d{14})$/);
  const stem = m ? m[1] : base; // filename without extension and trailing timestamp
  const timestamp = m ? m[2] : undefined;
  const tokens = stem.split("_").filter(Boolean);
  return { base, stem, timestamp, tokens };
}

function toBatchExportName(batch) {
  // Batch dirs are YYYYMMDD. Expose BYYMMDD for concise imports, e.g. 20260201 -> B260201.
  if (/^\d{8}$/.test(batch)) return `B${batch.slice(2)}`;
  return `B${toConstIdent(batch)}`;
}

function toConstIdent(s) {
  // Keep it readable and deterministic: A-Z0-9 and underscores only.
  return String(s)
    .replace(/[^a-zA-Z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "")
    .replace(/_+/g, "_")
    .toUpperCase();
}

function readSvgsInBatch(batch) {
  const dir = path.join(ROOT, batch);
  const files = fs
    .readdirSync(dir, { withFileTypes: true })
    .filter((d) => d.isFile() && d.name.toLowerCase().endsWith(".svg"))
    .map((d) => d.name)
    .sort();

  return files.map((filename) => {
    const parsed = parseFilename(filename);
    const relPath = `./${batch}/${filename}`;
    return {
      batch,
      filename,
      path: relPath,
      stem: parsed.stem,
      title: toTitle(parsed.tokens),
      tokens: parsed.tokens,
      timestamp: parsed.timestamp
    };
  });
}

function escapeJson(obj) {
  return JSON.stringify(obj, null, 2) + "\n";
}

function jsStringLiteral(s) {
  return JSON.stringify(s);
}

function writeFile(rel, content) {
  const abs = path.join(ROOT, rel);
  fs.mkdirSync(path.dirname(abs), { recursive: true });
  fs.writeFileSync(abs, content, "utf8");
}

function pickLatestByStem(entries) {
  // For scalable constant naming (without timestamps), keep one "latest" entry per stem.
  // If timestamps exist, lexicographic compare works for YYYYMMDDHHmmss.
  const byStem = new Map();
  for (const e of entries) {
    const cur = byStem.get(e.stem);
    if (!cur) {
      byStem.set(e.stem, e);
      continue;
    }
    const tA = cur.timestamp ?? "";
    const tB = e.timestamp ?? "";
    if (tB > tA) byStem.set(e.stem, e);
  }
  return Array.from(byStem.values()).sort((a, b) =>
    a.stem.localeCompare(b.stem)
  );
}

function generate() {
  const batches = listBatchDirs();
  const avatars = batches.flatMap((b) => readSvgsInBatch(b));

  // Group constants by batch, using the (timestamp-less) stem as the constant name.
  // If the same stem exists multiple times in a batch, we export only the latest one.
  const batchExports = new Map(); // batchName -> [{ constName, path }]
  for (const batch of batches) {
    const entries = avatars.filter((a) => a.batch === batch);
    const latest = pickLatestByStem(entries);
    const used = new Map();
    const constants = latest.map((a) => {
      let constName = toConstIdent(a.stem);
      const n = (used.get(constName) ?? 0) + 1;
      used.set(constName, n);
      if (n > 1) constName = `${constName}_${n}`;
      return { constName, path: a.path };
    });
    batchExports.set(toBatchExportName(batch), { batch, constants });
  }

  writeFile("index.json", escapeJson(avatars));

  const banner =
    "// Generated by scripts/generate-index.mjs. DO NOT EDIT BY HAND.\n";

  const mjsLines = [];
  mjsLines.push(banner);
  mjsLines.push(
    "export const avatars = Object.freeze([\n" +
      avatars
        .map((a) => {
          return (
            "  {\n" +
            `    batch: ${jsStringLiteral(a.batch)},\n` +
            `    filename: ${jsStringLiteral(a.filename)},\n` +
            `    path: ${jsStringLiteral(a.path)},\n` +
            `    stem: ${jsStringLiteral(a.stem)},\n` +
            `    title: ${jsStringLiteral(a.title)},\n` +
            `    tokens: ${jsStringLiteral(a.tokens)},\n` +
            (a.timestamp
              ? `    timestamp: ${jsStringLiteral(a.timestamp)},\n`
              : "") +
            `    url: new URL(${jsStringLiteral(a.path)}, import.meta.url).href\n` +
            "  }"
          );
        })
        .join(",\n") +
      "\n]);\n"
  );
  mjsLines.push("\n");
  for (const [exportName, data] of batchExports.entries()) {
    mjsLines.push(`export const ${exportName} = Object.freeze({\n`);
    for (const c of data.constants) {
      mjsLines.push(
        `  ${c.constName}: new URL(${jsStringLiteral(
          c.path
        )}, import.meta.url).href,\n`
      );
    }
    mjsLines.push("});\n\n");
  }
  if (batchExports.size) {
    const names = Array.from(batchExports.keys()).sort();
    mjsLines.push(
      `export const batches = Object.freeze({ ${names.join(", ")} });\n`
    );
  }
  writeFile("index.mjs", mjsLines.join(""));

  const cjsLines = [];
  cjsLines.push(banner);
  cjsLines.push(
    "const path = require('node:path');\n" +
      "const { pathToFileURL } = require('node:url');\n\n" +
      "function toFileUrl(relPath) {\n" +
      "  return pathToFileURL(path.join(__dirname, relPath)).href;\n" +
      "}\n\n"
  );
  cjsLines.push(
    "const avatars = Object.freeze([\n" +
      avatars
        .map((a) => {
          const relPath = a.path.startsWith("./") ? a.path.slice(2) : a.path;
          return (
            "  {\n" +
            `    batch: ${jsStringLiteral(a.batch)},\n` +
            `    filename: ${jsStringLiteral(a.filename)},\n` +
            `    path: ${jsStringLiteral(a.path)},\n` +
            `    stem: ${jsStringLiteral(a.stem)},\n` +
            `    title: ${jsStringLiteral(a.title)},\n` +
            `    tokens: ${jsStringLiteral(a.tokens)},\n` +
            (a.timestamp
              ? `    timestamp: ${jsStringLiteral(a.timestamp)},\n`
              : "") +
            `    url: toFileUrl(${jsStringLiteral(relPath)})\n` +
            "  }"
          );
        })
        .join(",\n") +
      "\n]);\n\n"
  );
  cjsLines.push("module.exports.avatars = avatars;\n");
  for (const [exportName, data] of batchExports.entries()) {
    cjsLines.push(`module.exports.${exportName} = Object.freeze({\n`);
    for (const c of data.constants) {
      const relPath = c.path.startsWith("./") ? c.path.slice(2) : c.path;
      cjsLines.push(
        `  ${c.constName}: toFileUrl(${jsStringLiteral(relPath)}),\n`
      );
    }
    cjsLines.push("});\n");
  }
  if (batchExports.size) {
    const names = Array.from(batchExports.keys()).sort();
    cjsLines.push(`module.exports.batches = Object.freeze({\n`);
    for (const n of names) cjsLines.push(`  ${n}: module.exports.${n},\n`);
    cjsLines.push("});\n");
  }
  writeFile("index.cjs", cjsLines.join(""));

  const dtsLines = [];
  dtsLines.push(banner);
  dtsLines.push(
    "export type AvatarEntry = {\n" +
      "  batch: string;\n" +
      "  filename: string;\n" +
      "  path: string;\n" +
      "  stem: string;\n" +
      "  title: string;\n" +
      "  tokens: readonly string[];\n" +
      "  timestamp?: string;\n" +
      "  url: string;\n" +
      "};\n\n"
  );
  dtsLines.push("export const avatars: readonly AvatarEntry[];\n\n");
  const batchNames = Array.from(batchExports.keys()).sort();
  for (const n of batchNames) {
    const data = batchExports.get(n);
    dtsLines.push(`export const ${n}: {\n`);
    for (const c of data.constants) {
      dtsLines.push(`  readonly ${c.constName}: string;\n`);
    }
    dtsLines.push("};\n\n");
  }
  if (batchNames.length) {
    dtsLines.push(
      "export const batches: {\n" +
        batchNames.map((n) => `  readonly ${n}: typeof ${n};`).join("\n") +
        "\n};\n"
    );
  }
  writeFile("index.d.ts", dtsLines.join(""));

  console.log(
    `Generated index for ${avatars.length} avatars across ${batches.length} batch(es).`
  );
}

generate();
