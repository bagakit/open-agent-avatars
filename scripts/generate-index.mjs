#!/usr/bin/env node
/* eslint-disable no-console */

import fs from "node:fs";
import path from "node:path";

const ROOT = path.resolve(process.cwd());

function isBatchDirName(name) {
  return /^\d{8}$/.test(name);
}

function listBatchDirs() {
  const dirs = fs
    .readdirSync(ROOT, { withFileTypes: true })
    .filter((d) => d.isDirectory() && isBatchDirName(d.name))
    .map((d) => d.name)
    .sort();

  // Only treat folders as "asset batches" if they actually contain SVGs.
  return dirs.filter((name) => {
    const abs = path.join(ROOT, name);
    try {
      const entries = fs.readdirSync(abs, { withFileTypes: true });
      return entries.some(
        (e) => e.isFile() && e.name.toLowerCase().endsWith(".svg")
      );
    } catch {
      return false;
    }
  });
}

function toTitle(tokens) {
  return tokens.join(" ").replace(/\s+/g, " ").trim();
}

function parseFilename(filename) {
  const ext = path.extname(filename);
  const base = ext ? filename.slice(0, -ext.length) : filename;
  const m = base.match(/^(.*)_(\d{14})$/);
  const stem = m ? m[1] : base; // filename without extension and trailing timestamp
  const timestamp = m ? m[2] : undefined;
  const tokens = stem.split("_").filter(Boolean);
  return { base, stem, timestamp, tokens };
}

function toConstIdent(s) {
  // Keep it readable and deterministic: A-Z0-9 and underscores only.
  return String(s)
    .replace(/[^a-zA-Z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "")
    .replace(/_+/g, "_")
    .toUpperCase();
}

function readSvgsInBatch(batch) {
  const dir = path.join(ROOT, batch);
  const files = fs
    .readdirSync(dir, { withFileTypes: true })
    .filter((d) => d.isFile() && d.name.toLowerCase().endsWith(".svg"))
    .map((d) => d.name)
    .sort();

  return files.map((filename) => {
    const parsed = parseFilename(filename);
    const relPath = `./${batch}/${filename}`;
    return {
      batch,
      filename,
      path: relPath,
      stem: parsed.stem,
      title: toTitle(parsed.tokens),
      tokens: parsed.tokens,
      timestamp: parsed.timestamp
    };
  });
}

function escapeJson(obj) {
  return JSON.stringify(obj, null, 2) + "\n";
}

function jsStringLiteral(s) {
  return JSON.stringify(s);
}

function writeFile(rel, content) {
  const abs = path.join(ROOT, rel);
  fs.mkdirSync(path.dirname(abs), { recursive: true });
  fs.writeFileSync(abs, content, "utf8");
}

function ensureEmptyDir(relDir) {
  const abs = path.join(ROOT, relDir);
  if (!fs.existsSync(abs)) {
    fs.mkdirSync(abs, { recursive: true });
    return;
  }
  const entries = fs.readdirSync(abs, { withFileTypes: true });
  for (const e of entries) {
    if (!e.isFile()) continue;
    if (!/\.(mjs|cjs|d\.ts|d\.cts)$/i.test(e.name)) continue;
    fs.unlinkSync(path.join(abs, e.name));
  }
}

function pickLatestByStem(entries) {
  // For scalable constant naming (without timestamps), keep one "latest" entry per stem.
  // If timestamps exist, lexicographic compare works for YYYYMMDDHHmmss.
  const byStem = new Map();
  for (const e of entries) {
    const cur = byStem.get(e.stem);
    if (!cur) {
      byStem.set(e.stem, e);
      continue;
    }
    const tA = cur.timestamp ?? "";
    const tB = e.timestamp ?? "";
    if (tB > tA) byStem.set(e.stem, e);
  }
  return Array.from(byStem.values()).sort((a, b) =>
    a.stem.localeCompare(b.stem)
  );
}

function generate() {
  const batches = listBatchDirs();
  const avatars = batches.flatMap((b) => readSvgsInBatch(b));

  writeFile("index.json", escapeJson(avatars));

  const banner =
    "// Generated by scripts/generate-index.mjs. DO NOT EDIT BY HAND.\n";

  const mjsLines = [];
  mjsLines.push(banner);
  mjsLines.push(
    "export const avatars = Object.freeze([\n" +
      avatars
        .map((a) => {
          return (
            "  {\n" +
            `    batch: ${jsStringLiteral(a.batch)},\n` +
            `    filename: ${jsStringLiteral(a.filename)},\n` +
            `    path: ${jsStringLiteral(a.path)},\n` +
            `    stem: ${jsStringLiteral(a.stem)},\n` +
            `    title: ${jsStringLiteral(a.title)},\n` +
            `    tokens: ${jsStringLiteral(a.tokens)},\n` +
            (a.timestamp
              ? `    timestamp: ${jsStringLiteral(a.timestamp)},\n`
              : "") +
            `    url: new URL(${jsStringLiteral(a.path)}, import.meta.url).href\n` +
            "  }"
          );
        })
        .join(",\n") +
      "\n]);\n"
  );
  writeFile("index.mjs", mjsLines.join(""));

  const cjsLines = [];
  cjsLines.push(banner);
  cjsLines.push(
    "const path = require('node:path');\n" +
      "const { pathToFileURL } = require('node:url');\n\n" +
      "function toFileUrl(relPath) {\n" +
      "  return pathToFileURL(path.join(__dirname, relPath)).href;\n" +
      "}\n\n"
  );
  cjsLines.push(
    "const avatars = Object.freeze([\n" +
      avatars
        .map((a) => {
          const relPath = a.path.startsWith("./") ? a.path.slice(2) : a.path;
          return (
            "  {\n" +
            `    batch: ${jsStringLiteral(a.batch)},\n` +
            `    filename: ${jsStringLiteral(a.filename)},\n` +
            `    path: ${jsStringLiteral(a.path)},\n` +
            `    stem: ${jsStringLiteral(a.stem)},\n` +
            `    title: ${jsStringLiteral(a.title)},\n` +
            `    tokens: ${jsStringLiteral(a.tokens)},\n` +
            (a.timestamp
              ? `    timestamp: ${jsStringLiteral(a.timestamp)},\n`
              : "") +
            `    url: toFileUrl(${jsStringLiteral(relPath)})\n` +
            "  }"
          );
        })
        .join(",\n") +
      "\n]);\n\n"
  );
  cjsLines.push("module.exports.avatars = avatars;\n");
  writeFile("index.cjs", cjsLines.join(""));

  const dtsLines = [];
  dtsLines.push(banner);
  dtsLines.push(
    "export type AvatarEntry = {\n" +
      "  batch: string;\n" +
      "  filename: string;\n" +
      "  path: string;\n" +
      "  stem: string;\n" +
      "  title: string;\n" +
      "  tokens: readonly string[];\n" +
      "  timestamp?: string;\n" +
      "  url: string;\n" +
      "};\n\n"
  );
  dtsLines.push("export const avatars: readonly AvatarEntry[];\n\n");
  writeFile("index.d.ts", dtsLines.join(""));

  // Only generate per-icon modules for a single "current" batch to keep the repo/package size reasonable.
  // Default is 20260202, but can be overridden for regeneration.
  const desiredExportBatch = process.env.AVATARS_EXPORT_BATCH ?? "20260202";
  const exportBatch = batches.includes(desiredExportBatch)
    ? desiredExportBatch
    : batches[batches.length - 1];
  if (!exportBatch) throw new Error("No batch dirs found (expected YYYYMMDD/).");

  // Generate per-icon modules per batch:
  // - one icon per module file for stable, tree-shakeable consumption
  // - batch index re-exports for ergonomic `import { X } from "@pkg/20260202"`
  for (const batch of batches) {
    if (batch !== exportBatch) continue;
    const entries = avatars.filter((a) => a.batch === batch);
    const latest = pickLatestByStem(entries);

    const used = new Map();
    const iconModules = latest.map((a) => {
      let name = toConstIdent(a.stem);
      const n = (used.get(name) ?? 0) + 1;
      used.set(name, n);
      if (n > 1) name = `${name}_${n}`;
      return { name, svgFilename: a.filename };
    });

    const modDir = `${batch}/mod`;
    ensureEmptyDir(modDir);

    const batchIndexMjs = [];
    batchIndexMjs.push(banner);
    for (const m of iconModules) {
      batchIndexMjs.push(
        `export { default as ${m.name} } from ${jsStringLiteral(
          `./mod/${m.name}.mjs`
        )};\n`
      );
    }
    writeFile(`${batch}/index.mjs`, batchIndexMjs.join(""));

    const batchIndexCjs = [];
    batchIndexCjs.push(banner);
    for (const m of iconModules) {
      batchIndexCjs.push(
        `module.exports.${m.name} = require(${jsStringLiteral(
          `./mod/${m.name}.cjs`
        )});\n`
      );
    }
    writeFile(`${batch}/index.cjs`, batchIndexCjs.join(""));

    const batchIndexDts = [];
    batchIndexDts.push(banner);
    for (const m of iconModules) {
      batchIndexDts.push(`export const ${m.name}: string;\n`);
    }
    writeFile(`${batch}/index.d.ts`, batchIndexDts.join(""));

    for (const m of iconModules) {
      const svgRelFromMod = path.posix.join("..", m.svgFilename);

      writeFile(
        `${modDir}/${m.name}.mjs`,
        banner +
          `export default new URL(${jsStringLiteral(
            svgRelFromMod
          )}, import.meta.url).href;\n`
      );

      writeFile(
        `${modDir}/${m.name}.cjs`,
        banner +
          "const path = require('node:path');\n" +
          "const { pathToFileURL } = require('node:url');\n\n" +
          `module.exports = pathToFileURL(path.join(__dirname, ${jsStringLiteral(
            svgRelFromMod
          )})).href;\n`
      );

      writeFile(
        `${modDir}/${m.name}.d.ts`,
        banner + "declare const url: string;\nexport default url;\n"
      );
    }
  }

  console.log(
    `Generated index for ${avatars.length} avatars across ${batches.length} batch(es). Exported batch: ${exportBatch}.`
  );
}

generate();
